# ADR-0004: SQS for Async Job Processing

## Status
Accepted

## Context
The system requires asynchronous processing for calendar synchronization and email notifications. We need a reliable message queue that integrates well with AWS and supports our use cases.

**Options Considered:**
1. **AWS SQS** - Managed queue service with Lambda integration
2. **AWS EventBridge** - Event bus with routing rules
3. **RabbitMQ on EC2** - Self-hosted message broker
4. **Redis Pub/Sub** - In-memory messaging (already using Redis for cache)
5. **Database as Queue** - Polling jobs table

**Evaluation Criteria:**
- Reliability and message durability
- AWS integration and operational simplicity
- Cost at expected volume
- Dead-letter queue support
- At-least-once delivery guarantees

## Decision
We will use **AWS SQS with Lambda workers** for async job processing.

Implementation approach:
- **Queues**:
  - `notification-queue` - Email and push notifications
  - `calendar-sync-queue` - Calendar synchronization jobs
  - Dead-letter queues for failed messages
- **Consumers**: Lambda functions triggered by SQS events
- **Message Format**: JSON payloads with event type and metadata
- **Retry Strategy**: Exponential backoff with max 3 retries, then DLQ
- **Visibility Timeout**: 5 minutes for calendar sync, 30 seconds for notifications

## Consequences

### Positive
- **Fully Managed**: No infrastructure to maintain; auto-scaling built-in
- **Reliable**: Durable message storage, at-least-once delivery
- **Cost Effective**: Pay per request; free tier covers development
- **Lambda Integration**: Native event source mapping for workers
- **DLQ Support**: Automatic handling of failed messages for investigation

### Negative
- **Message Ordering**: Standard SQS does not guarantee FIFO (acceptable for our use cases)
- **Visibility Timeout Tuning**: Requires careful configuration to prevent duplicate processing
- **AWS Lock-in**: Tight coupling to AWS ecosystem

### Risks & Mitigations
- **Risk**: Message processing failures go unnoticed
  - **Mitigation**: CloudWatch alarms on DLQ depth, monitoring for processing errors
- **Risk**: Duplicate message processing (at-least-once semantics)
  - **Mitigation**: Implement idempotency keys for calendar sync and notifications
- **Risk**: Queue backlog during traffic spikes
  - **Mitigation**: Lambda concurrency limits, SQS FIFO queue for critical paths if needed

### Follow-up
- Implement idempotency logic in workers (store processed message IDs)
- Set up CloudWatch alarms for queue depth and DLQ messages
- Load test with 10K messages to validate Lambda scaling
- Document retry and DLQ investigation procedures
