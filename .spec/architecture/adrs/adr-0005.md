# ADR-0005: JWT Authentication with Redis Sessions

## Status
Accepted

## Context
The system requires secure authentication and authorization for REST API and WebSocket connections. We need a scalable approach that supports multi-instance deployment and stateless API design.

**Options Considered:**
1. **JWT (JSON Web Tokens) with Redis sessions** - Stateless tokens with server-side session storage
2. **Session Cookies with Database** - Traditional server-side sessions in PostgreSQL
3. **OAuth2 Proxy** - Delegate authentication to external provider (Auth0, Cognito)
4. **Opaque Tokens with Database Lookup** - Random tokens stored in database

**Evaluation Criteria:**
- Scalability across multiple API instances
- Security (token revocation, expiration)
- WebSocket authentication support
- Developer experience
- Cost and operational complexity

## Decision
We will use **JWT with short expiration and Redis-backed refresh tokens**.

Implementation approach:
- **Access Tokens**: JWT with 15-minute expiration, containing user ID, organization ID, roles
- **Refresh Tokens**: Opaque tokens stored in Redis with 7-day expiration
- **Token Signing**: RSA-256 asymmetric keys (private for signing, public for validation)
- **WebSocket Auth**: JWT passed in handshake, validated before connection established
- **Token Revocation**: Redis blacklist for logout, org-wide revocation on security events

Token payload structure:
```json
{
  "sub": "user-id",
  "org": "organization-id",
  "roles": ["member"],
  "exp": 1234567890,
  "iat": 1234567000
}
```

## Consequences

### Positive
- **Stateless API**: No session lookup required for API requests; scales horizontally
- **Fast Validation**: JWT validation is local operation (asymmetric signature check)
- **Cross-Service Ready**: Same token works for API and WebSocket
- **Flexible Claims**: Can include organization ID, roles for authorization
- **Refresh Flow**: Allows long-lived sessions without long-lived access tokens

### Negative
- **Token Revocation Complexity**: JWTs can't be invalidated before expiration (mitigated by short TTL + blacklist)
- **Token Size**: JWTs larger than opaque tokens (mitigated by compression in transit)
- **Key Management**: Requires secure storage and rotation of signing keys

### Risks & Mitigations
- **Risk**: Stolen JWT used before expiration
  - **Mitigation**: Short 15-minute TTL, Redis blacklist on logout, HTTPS only
- **Risk**: Refresh token compromise
  - **Mitigation**: Store hashed in Redis, rotate on use (refresh token rotation), HTTP-only cookies
- **Risk**: JWT signing key compromise
  - **Mitigation**: Store in AWS Secrets Manager, implement key rotation procedure

### Follow-up
- Implement automated key rotation every 90 days
- Add introspection endpoint for token validation (for admin tools)
- Monitor Redis for token blacklist size and eviction
- Document token refresh flow and error handling for clients
- Consider adding device fingerprinting for additional security
