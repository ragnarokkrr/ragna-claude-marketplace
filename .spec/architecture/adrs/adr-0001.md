# ADR-0001: Modular Monolith vs Microservices

## Status
Accepted

## Context
We need to decide on the high-level architecture pattern for the task management system. The team consists of 3-5 developers with a 3-month MVP timeline. The system must support 10,000 concurrent users and multi-tenant data isolation.

**Options Considered:**
1. **Microservices Architecture** - Separate services for tasks, projects, notifications, calendar integration
2. **Modular Monolith** - Single deployable with clear bounded context boundaries
3. **Serverless (Function-as-a-Service)** - Individual Lambda functions per API endpoint

**Evaluation Criteria:**
- Development velocity for small team
- Operational complexity
- Scalability to 10K users
- Cost efficiency
- Future evolution path

## Decision
We will adopt a **Modular Monolith with Hexagonal Architecture**.

The application will be structured as:
- Single deployable unit (Node.js application)
- Clear bounded contexts (Task Management, Projects, Notifications, Calendar, Audit, Identity)
- Hexagonal architecture with ports/adapters pattern
- Vertical slice organization within each context
- Shared database with proper indexing and connection pooling

## Consequences

### Positive
- **Faster Development**: No distributed system complexity; faster feature delivery for small team
- **Simplified Debugging**: Single codebase with unified logging and tracing
- **Reduced Operational Overhead**: One deployment pipeline, simpler monitoring
- **Cost Efficient**: Single database, fewer infrastructure components
- **Strong Consistency**: ACID transactions across all features
- **Easy Local Development**: Developers can run entire system locally

### Negative
- **Scaling Granularity**: Cannot scale individual components independently (mitigated by horizontal scaling of entire app)
- **Technology Lock-in**: All code in same runtime (Node.js/TypeScript)
- **Future Migration Effort**: If microservices needed, requires refactoring (mitigated by bounded context boundaries)

### Risks & Mitigations
- **Risk**: Monolith becomes tangled over time
  - **Mitigation**: Enforce bounded context boundaries via module structure, architectural tests
- **Risk**: Single point of failure
  - **Mitigation**: Multi-instance deployment with load balancing, database Multi-AZ failover

### Follow-up
- Document bounded context boundaries clearly for future microservices extraction if needed
- Implement module dependency rules (e.g., using linting or architecture testing tools)
- Monitor application metrics to identify scaling bottlenecks early
